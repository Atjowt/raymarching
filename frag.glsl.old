#version 330 core

uniform float uTime;
uniform vec2 uMouse;

in vec2 TexCoord;
out vec4 FragColor;

struct Material {
    vec3 diffuseColor;
    vec3 specularColor;
    float specular;
};

struct Ray {
    vec3 origin, direction;
};

struct Hit {
    float distance;
    Material material;
};

struct Camera {
    vec3 pos;
    vec3 dir;
};

Camera cam = Camera(vec3(0.0, 0.0, -8.0), vec3(0.0, 0.0, 1.0));

Material mixMat(Material a, Material b, float t) {
    Material mat;
    mat.diffuseColor = mix(a.diffuseColor, b.diffuseColor, t);
    mat.specularColor = mix(a.specularColor, b.specularColor, t);
    mat.specular = mix(a.specular, b.specular, t);
    return mat;
}

Hit mixHit(Hit a, Hit b, float t) {
    Hit hit;
    hit.distance = mix(a.distance, b.distance, t);
    hit.material = mixMat(a.material, b.material, t);
    return hit;
}

Hit minHit(Hit a, Hit b) {
    return mixHit(b, a, float(a.distance < b.distance));
}

mat2 rotate2D(float a) {
    float s = sin(a);
    float c = cos(a);
    return mat2(c, -s, s, c);
}

mat3 scale3D(vec3 s) {
    return mat3(
        1.0 / s.x, 0.0, 0.0,
        0.0, 1.0 / s.y, 0.0,
        0.0, 0.0, 1.0 / s.z
    );
}

mat4 translate(vec3 t) {
    return mat4(
        1.0, 0.0, 0.0, t.x,
        0.0, 1.0, 0.0, t.y,
        0.0, 0.0, 1.0, t.z,
        0.0, 0.0, 0.0, 1.0
    );
}

float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * k * 0.1667;
}

float sdSphere(vec3 p) {
    return length(p) - 1.0;
}

float sdBox(vec3 p) {
    return length(max(abs(p) - 1.0, 0.0));
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float extrude(float V, float L) {
    return V - min(L, max(0.0, V));
}

float bUnion(float a, float b) {
    return min(a, b);
}

float bDifference(float a, float b) {
    return max(a, -b);
}

Material matWhiteFlat = Material(
        vec3(1.0, 1.0, 1.0), // Albedo
        vec3(1.0), // Specular
        1.0 // Shininess
    );

Material matRedGlossy = Material(
        vec3(1.0, 0.0, 0.0), // Albedo
        vec3(1.0), // Specular
        32.0 // Shininess
    );

Material matGreenGlossy = Material(
        vec3(0.0, 1.0, 0.0), // Albedo
        vec3(1.0), // Specular
        32.0 // Shininess
    );

Material matBlueGlossy = Material(
        vec3(0.0, 0.0, 1.0), // Albedo
        vec3(1.0), // Specular
        32.0 // Shininess
    );

Material matYellowGlossy = Material(
        vec3(1.0, 1.0, 0.0), // Albedo
        vec3(1.0), // Specular
        32.0 // Shininess
    );

Material matPinkGlossy = Material(
        vec3(1.0, 0.1, 1.0), // Albedo
        vec3(1.0), // Specular
        32.0 // Shininess
    );

Material matDonutBase = Material(
        vec3(0.5, 0.3, 0.1), // Albedo
        vec3(1.0), // Specular
        32.0 // Shininess
    );

const float axisLength = 1.0;
const float axisThick = 0.04;

Hit hitOrigin(vec3 p) {
    return Hit(
        sdSphere(p / (axisThick * 2.0)) * (axisThick * 2.0),
        matYellowGlossy
    );
}

Hit hitUnitAxisX(vec3 p) {
    p.x = extrude(p.x, axisLength);
    return Hit(
        sdSphere(p / axisThick) * axisThick,
        matRedGlossy
    );
}

Hit hitUnitAxisY(vec3 p) {
    p.y = extrude(p.y, axisLength);
    return Hit(
        sdSphere(p / axisThick) * axisThick,
        matGreenGlossy
    );
}

Hit hitUnitAxisZ(vec3 p) {
    p.z = extrude(p.z, axisLength);
    return Hit(
        sdSphere(p / axisThick) * axisThick,
        matBlueGlossy
    );
}

Hit hitUnitAxes(vec3 p) {
    Hit hit = hitOrigin(p);
    hit = minHit(hit, hitUnitAxisX(p));
    hit = minHit(hit, hitUnitAxisY(p));
    hit = minHit(hit, hitUnitAxisZ(p));
    return hit;
}

Hit hitCube1(vec3 p) {
    return Hit(
        sdBox(p),
        matWhiteFlat
    );
}

Hit hitTorus1(vec3 p) {
    p -= 1000.0 * noise3(p / 100.0);
    return Hit(
        sdTorus(p, vec2(2.0, 1.0)),
        matDonutBase
    );
}

Hit hitIcing1(vec3 p) {
    p.y -= 0.2;
    return Hit(
        hitTorus1(p).distance,
        matPinkGlossy
    );
}

Hit hitDonut1(vec3 p) {
    return minHit(hitTorus1(p), hitIcing1(p));
}

Hit hitWorld(vec3 p) {
    Hit world = hitUnitAxes(p);
    world = minHit(world, hitDonut1(p));
    return world;
}

vec3 calcNormal(vec3 p) {
    float h = 0.001;
    return normalize(vec3(
            hitWorld(p + vec3(h, 0.0, 0.0)).distance - hitWorld(p - vec3(h, 0.0, 0.0)).distance,
            hitWorld(p + vec3(0.0, h, 0.0)).distance - hitWorld(p - vec3(0.0, h, 0.0)).distance,
            hitWorld(p + vec3(0.0, 0.0, h)).distance - hitWorld(p - vec3(0.0, 0.0, h)).distance
        ));
}

const vec3 lightPos = vec3(4.0, 4.0, 4.0);
const vec3 lightColor = vec3(1.0, 1.0, 1.0);

vec3 colorBackground(Ray ray) {
    vec3 loColor = vec3(0.8, 0.8, 0.8);
    vec3 hiColor = vec3(0.5, 0.6, 1.0);
    return mix(loColor, hiColor, 0.5 + 0.5 * ray.direction.y);
    // return ray.direction;
    // return vec3(0.0);
}

const vec3 ambientColor = vec3(0.01, 0.01, 0.01);
const float screenGamma = 2.2;
vec3 colorMaterial(Material material, vec3 p, vec3 normal) {
    vec3 lightDir = lightPos - p;
    vec3 viewDir = normalize(p - cam.pos);

    float diffuse = max(dot(normal, lightDir), 0.0);
    vec3 diffuseColor = diffuse * lightColor * material.diffuseColor;

    vec3 halfDir = normalize(lightDir + viewDir);
    float specAngle = max(dot(halfDir, normal), 0.0);
    float specular = pow(specAngle, material.specular);
    vec3 specularColor = specular * lightColor * material.specularColor;

    vec3 colorLinear = ambientColor + diffuseColor + specularColor;
    vec3 colorCorrected = pow(colorLinear, vec3(1.0 / screenGamma));

    return colorCorrected;
}

const float maxDist = 100.0;
const float minDist = 0.001;
const int maxSteps = 100;

vec3 march(Ray ray) {
    float t = 0.0;

    for (int i = 0; i < maxSteps; i++) {
        vec3 p = ray.origin + t * ray.direction;

        Hit hit = hitWorld(p);
        float d = hit.distance;

        if (d < minDist) {
            vec3 normal = calcNormal(p);
            return colorMaterial(hit.material, p, normal);
        }

        t += d;

        if (t > maxDist) break;
    }

    return colorBackground(ray);
}

void main(void) {
    vec2 uv = TexCoord - vec2(0.5);
    vec2 mouse = uMouse - vec2(0.5);
    Ray ray = Ray(
            cam.pos,
            normalize(vec3(uv, 1.0))
        );
    ray.origin.yz *= rotate2D(1.0 * -mouse.y);
    ray.direction.yz *= rotate2D(1.0 * -mouse.y);
    ray.origin.xz *= rotate2D(1.0 * -mouse.x);
    ray.direction.xz *= rotate2D(1.0 * -mouse.x);
    vec3 color = march(ray);
    FragColor = vec4(color, 1.0);
}
